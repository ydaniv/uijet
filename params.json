{"name":"uijet","tagline":"Killer UI for web-apps.","body":"# uijet\r\n\r\nKiller UI for web apps.\r\n\r\n## In short\r\n\r\nuijet lets you create awesome, cross-platform applications and keeps your code maintainable.\r\n\r\nuijet creates another layer of abstraction allowing you to focus \r\non flow of your application's logic while you generate code of the highest quality.\r\n\r\n### Main emphasis\r\n\r\n* Event-driven.\r\n* Decouple everything.\r\n* Reuse everything. Especially external libraries.\r\n* Code quality and maintainability.\r\n* Complete portability of same codebase across different platforms.\r\n* High performance and solid memory management.\r\n* Scalable architecture.\r\n* Reusable components.\r\n* Declarative code, in JS (not just markup!)\r\n\r\n## Srsly now, what's it all about\r\n\r\nuijet allows you to create UI from a rapid prototype to a full-blown-large-scale application.\r\nuijet performs 3 main roles:\r\n\r\n* IoC container for your application, and injects dependencies into your app and UI components.\r\n* Glues all your favorite libraries with a consistent API which makes them easily swappable.\r\n* Maintainable and scalable UI made of declarative, reusable, decoupled components. \r\n\r\n## Concepts\r\n\r\n### Modules\r\n\r\nuijet embraces the principle of doing 1 thing (or at most 2) and doing it right.\r\n\r\nThat's why it leaves the implementation of all the main parts of the application up \r\nto external libraries, of your choice, and glues them together into a coherent interface \r\nwhich allows them to be abstracted and easily swappable.\r\n\r\n#### uijet.use\r\n\r\nThe entry point of adding a module into uijet.\r\n\r\n### Widgets\r\n\r\nThese are the most basic building blocks for creating any type of UI component.\r\nuijet gives you the tools for both extending them and composing them together to form \r\nthe components we all know and love.\r\n\r\n#### uijet.Widget\r\n\r\nDefines a class of a reusable component.\r\n\r\n*Examples*: Pane, Button, List, etc.\r\n\r\n#### uijet.Factory\r\n\r\nDeclares a blueprint for a factory of a component's instance.\r\n\r\n#### uijet.declare\r\n\r\nDeclares an instance of a component in the app.\r\n\r\n#### uijet.start\r\n\r\nInitializes a component's instance(s), and registers it (them) into\r\nuijet's sandbox.\r\n\r\n### Composites\r\n\r\nMore comprehensive components which extends the basic, generic widgets and mixes them \r\ninto a single component.\r\n\r\nThis is usually done by providing `uijet.Wiget()` the third parameter which defines \r\ndependencies for this component class.\r\n\r\n*Examples*: Datepicker, Slider, Teaser, Modal, etc.\r\n\r\n### Mixins & Adapters\r\n\r\nMaintainability is all about deconstructing your code into small pieces \r\nwhich perform a single main task, and then mixing them together.\r\n\r\nMixins are specifically for encapsulating behaviors for components, and \r\nthen enhance components with these behaviors as desired.\r\n\r\n*Examples*: Toggled, Templated, Transitioned, etc.\r\n\r\nAdapters are usually for adding missing behavior by acting as a mediator \r\nto external libraries which implement that code, and abstract those libraries \r\nwith a consistent API.\r\n\r\n*Example*: if you want a List component to be scrolled using a JS based plugin, \r\ntargeted for mouse wheel when used on desktop, and then with a different library, \r\ntargeted for touch gestures when used on handheld devices.\r\n\r\n#### uijet.Mixin\r\n\r\nDefines a Mixin that can be injected into components' classes.\r\nMixins are always injected on top of Widget dependencies and before the instance object.\r\n\r\n#### uijet.Adapter\r\n\r\nDefines an Adapter that can be injected onto a component's instances.\r\nAdapters' properties are always copied to the instance object (the top of the prototype chain).\r\n\r\n### Events & Signals\r\n\r\nuijet component instances do not return a handle you can imperatively execute methods with, hence\r\nthe only way you can perform actions on components or achieve inter component communication is via\r\nregistering handlers to events.\r\n\r\nAll handlers are always bound to the instance, so inside them you can use `this` as a handle to the instance.\r\n\r\n#### Signals\r\n\r\nEvents triggered during a widget's lifecycle and provide an inner component API.\r\n\r\nSignals usually take the form of an AOP like handlers, e.g. `pre_methodname`, `post_methodname`.\r\n\r\n#### DOM Events\r\n\r\nThe familiar DOM events triggered by user interaction.\r\nThese are always bound to the instance's `$element`.\r\nuijet makes extensive use of event delegation and bounds by default only to widgets.\r\nSo, for example, in a List widget all click events on the child items are bound to the list\r\ncontainer and handled at that level.\r\n\r\n#### App Events\r\n\r\nCustom events for inter-component communication, or simply to publish events between different\r\nmodules, e.g. between the uijet sandbox and components, or a router and components.\r\n\r\n## uijet.css\r\n\r\nA baseline stylesheet that defines basic structure for widgets, basic behavior for mixins,\r\nand some helper classes for managing the component's lifecycle.\r\n\r\nuijet.css does very little style resetting that's more targeted for applications, rather then\r\nsimple content webpages.\r\n\r\nIt's recommended to complement it with [normalize.css](http://necolas.github.io/normalize.css/).\r\n\r\n### Theming\r\n\r\nCurrently there are no bundled themes in uijet.\r\nHopefully, in the future there will be.\r\n\r\n## Documentation\r\n\r\nYou can generate documentation with [Grunt](http://gruntjs.com/):\r\n\r\n1. Install development dependencies:\r\n\r\n```bash\r\nnpm install\r\n```\r\n\r\n2. Generate documentation and start a static server to view it with:\r\n\r\n```bash\r\ngrunt rtfm\r\n```\r\n\r\nThen open `localhost:8000` in your browser.\r\n\r\n## Quick start\r\n\r\nGrab the a boilerplate from `boilerplates` and open `index.html` in your browser.\r\n\r\n## Dependencies\r\n\r\nuijet has no direct dependencies, however:\r\n\r\n * It favors the use of an AMD module loader, like [RequireJS](http://requirejs.org/) or [curl.js](https://github.com/cujojs/curl).\r\n * The list of available module adapters is currently short, but you can easily create your own.\r\n\r\n### Required dependencies\r\n\r\nFor uijet to run you must include an adapter in your app from each of the following Modules:\r\n\r\n * pubsub\r\n * promises\r\n * dom\r\n\r\nAll the rest are completely up to you.\r\n\r\n### Mandatory Modules' APIs\r\n\r\nAlthough the dependency may be indirect, uijet does enforce a strict API that each Module adapter \r\nmust adhere to.\r\nThis requirement is a must for the top 3 Modules mentioned above, and a few other Mixins and Composites, \r\nwhich rely on other Modules.\r\nThe API enforcing is also what makes a Module swappable at any given point without any impact \r\non the underlying framework. In some cases even no impact at all, whatsoever, on your application.\r\n\r\n*Example*: a dom Module adapter must be consistent with [jQuery](http://api.jquery.com/)'s API, so you\r\ncan choose either that, or [Zepto](http://zeptojs.com/), \r\nor with a little effort even [Bonzo](https://github.com/ded/bonzo) and [Bean](https://github.com/fat/bean).\r\n\r\n## Author\r\n\r\nYehonatan Daniv\r\n\r\n## Special thanks\r\n\r\nVenvid Technologies\r\n\r\nJetBrains, for their awesome IDE.\r\n<br/>\r\n<a href=\"http://www.jetbrains.com/pycharm/\"><img src=\"http://www.jetbrains.com/img/logos/pycharm_logo.gif\" width=\"250\" alt=\"PyCharm logo\"/></a>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}